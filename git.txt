
#need to tell Git who we are. We can do this by using
the Git config command 
git config --global user.email "me@example.com"
git config --global user.name "My name"

there are two ways to start working with a git repository.
1-We can create one from scratch using the git init command 
2-or we can use the git clone command to make a copy of a repository that already exists somewhere else. 

We can also use the ls-l.git command to look inside of it and see the many different things it contains. This is called a Git directory.

To make Git track our file, we'll add it to the project using the git add command passing the file that we want as a parameter. With that, we've added our file to the staging area

We can use the git status command to get some information about the current working tree and pending changes.


We see that our new file is marked to be committed, this means that our change is currently in the staging area. To get it committed into the.git directory, we run the git commit command.

When we operate with Git, our files can be either tracked or untracked.
Tracked files are part of the snapshots, while untracked files aren't a part of snapshots yet.
This is the usual case for new files. 
Each track file can be in one of three main states, modified, staged or committed. 

When we call Git add, we're telling Git that we want to add the current changes in that file to the list of changes to be committed.
This means that our file is currently part of the staging area, and it will be committed once we run the next Git command, Git commit. 

git commit -m "whatever u wanna write"

checkout current configuration by using the git config -l command

git add command will immediately move a new file from untracked to stage status.
And as we'll see later, it will also change a file in the modified state to staged state.
There's a git command used to display these commit messages called git log.  
The first commit in the list also says that the head indicator is pointing to the master branch
we can skip the staging step and go directly to the commit. No dress rehearsals. We do this by using the git commit -a

git commit -a -m "write ur commit directily"
when you use the -a shortcut, you skip the staging area. Meaning, you can't add any other changes before creating the commit.
 -p flag. The p comes from patch, because using this flag gives us the patch that was created. git log -p
git show. This command takes a commit ID as a parameter, and will display the information about the commit and the associated patch

Another interesting flag for git log is the --stat flag. This will cause git log to show some stats about the changes in the commit, like which files were changed and how many lines were added or removed.

git diff see the last changes u made

-p flag with the git add command. When we use this flag, git will show us the change being added and ask us if we want to stage it or not
git add -p /If we call git diff again, it won't show any differences, since git diff shows only unstaged changes by default. 
 we can call git diff -- staged to see the changes that are staged but not committe . 
 
 git rm remove file repo (commited)
 to remove unstaged (rm -f filename)
 to remove untraked (clean -d -f file 
 git mv to rename file
 
if there are files that get automatically generated by our scripts, or our operating system generates artifacts that we don't want in our repo, we'll want to ignore them so that they don't add noise to the output of git status. 
To do this, we can use the gitignore file.  Inside this file, we'll specify rules to tell git which files to skip for the current repo.

 You can change a file back to its earlier committed state by using the git checkout command followed by the name of the file
if you need to check out individual changes instead of the whole file, you can do that using the -p

If we realize we've added something to the staging area that we didn't actually want to commit, we can unstage our changes by using the git reset 

if we use a command like git add *, where the star is a file glob pattern used in Bash that expands to all files. This command will end up adding any change done in the working tree to the staging area

git reset HEAD <file name > or git restore --staged <file> untrack the file tracked from git add *

git reset -p to get git to ask you which specific changes you want to reset.

git commit --amend overwrite the previous commit (modify & add changes to the most recent commit)

git revert HEAD rollback commits in Git "Git revert doesn't just mean undo. Instead, it creates a commit that contains the inverse of all the changes made in the bad commit in order to cancel them out , but the history of the commits in the project remains consistent leaving a record of exactly what happened."

specific Head use git revert HEAD ~no for commit u want

git log -p -2 the dash P parameter lets us see the patch created by the commit while the dash two perimeter limits the output to the last two entries.

git show (id) to sow specific commit

git branch to see branches
git branch + name tocreate new branch
git checkout branchname to switch to this branch
fasterwase to create & switch in same time gitcheckout -b branchname

git checkout switch branches by updating the working tree to match select branch

git branch -d file name remove branch localy , to remove it remot repo git push origin --delete branchname
git branch -D to remove unmerged branch without needing to merge
when we switch branches in git, the working directory and commit history will be changed to reflect the snapshot of our project in that branch.

One thing to note after all this back and forth, is that each branch is just a pointer to a specific commit in a series of snapshots

after switch to master/main we mege by using git merge branchname

so What happens when we merge two branches Both branches are pointed at the same commit,cuz Merging combines branched data and history together.


Git uses two different algorithms to perform a merge, fast-forward and three-way merge. 

fast-forward : This kind of merge occurs when all the commits in the checked out branch are also in the branch that's being merged. If 
this is the case, we can say that the commit history of both branches doesn't diverge. In these cases, all Git has to do is update the 
pointers of the branches to the same commit

three-way merge is performed when the history of the merging branches has diverged in some way, and there isn't a nice linear path to 
combine them via fast-forwarding. This happens when a commit is made on one branch after the point when both branches split.

merge coflict to abort it use git merge --abort when we open our file that case conflict we see arrow and all changes make conflict what we want to keep & so on 
then git add file then git commit write ur commit and merge will done

git log --graph --oneline This shows a summarized view of the commit history for a repo.


 can send our changes to that remote repository by using the git push command which will gather all the snapshots we've taken and send them to the remote repository.

There are a couple ways to avoid having to do this. One way is to create an SSH key pair and store the public key in our profile so that  GitHub recognizes our computer. Another option is to use a credential helper which caches our credentials for a time window so that we don't need to enter our password with every interaction. Git already comes with a credential helper baked in. We just need to enable it. We do that by calling git config --global credential.helper cache.

git pull which is the command we use to retrieve new changes from the repository./used to fetch the newest updates from a remote repository

When we call a git clone to get a local copy of a remote repository, Git sets up that remote repository with the default origin name. We can look at the configuration for that remote by running git remote -v 


If we want to get even more information about our remote, we can call git remote show origin.

Git uses remote branches to keep copies of the data that's stored in the remote repository. We could have a look at the remote branches that our Git repo is currently tracking by running git branch -r

git branch -a same with appear branches  

If we want to make a change to a remote branch, what must Pull the remote branch, merge it with the local branch, then push it back to its origin. We still have to go through the normal workflow to change remote branches. (git pull)


The first time we push a branch to a remote repo, we need to add a few more parameters to the Git push command. We'll need to add the -u flag to create the branch upstream, which is another way of referring to remote repositories


git rebase branchname another option to merge (alternative to merge), it means changing the base commit that's used for our branch.

The problem with three way merges is that because of the split history, it's hard for us to debug when an issue is found in our code, and we need to understand where the problem was introduced. By changing the base where our commits split from the branch history, we can replay the new commits on top of the new base. This allows Git to do a fast forward merge and keep history linear



create a single commit that includes both changes and a more detailed description than the one we submitted. We can do that by using the interactive version of the rebase command called rebase-i + main or branch

 When we call an interactive rebase, a text editor opens with a list of all the selected commits from the oldest to the most recent. By changing the first word of each line, we can select what we want to do with the commits. The default action here is pick which takes the commits and rebases them against the branch we selected.
 
 We have two options for combining commits, squash and fix up , In both cases, the contents of the selected commit are merged into the previous commit in the list. The difference is what happens with the commit messages. When we choose squash, the commit messages are added together and an editor opens up to let us make any necessary changes. When we choose fix up, the commit message for that commit is discarded

Once we've told git that we want to squash a commit unto the one before it, we're given another file to edit. In this case, it's the combined commit message

in this case, we don't want to create a merge. Instead, we want to replace the old commits with the new one. To do this, we will call git push -f to force git to push the current snapshot into the repo as is.










